// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.0;

import "./Distributor.sol";
import "./Consumer.sol";
import "./Ownable.sol";
import "./Retailer.sol";
import "./Farmer.sol";
import "./Roles.sol";

contract Supply_chain is  Distributor, Consumer, Retailer, Farmer{

// inizio a definire la struttura della mia supply chain, specificando tutte le variabili...

// three structures for their respective three roles
// interesting features of a product
    struct Product_M{
        address farm_address;
        string farm_name;
        string farm_seat;
        string product_name;
        uint32 production_date; // there isnt a date format in solidity..., so we work with block.timestamp
        uint32 expiration_date;
        uint32 weight_kg;
        uint price; // total price
        uint unique_id;
    }

    struct Product_D{
        address distr_address;
        string distr_name;
        string product_name;
        uint unique_id;
        uint price;
        uint32 weight_kg;
        uint32 production_date; 
        uint32 expiration_date;
    }

    struct Product_R{
        address ret_address;
        string ret_name;
        string ret_seat;
        string product_name;
        uint32 production_date; 
        uint32 expiration_date;
        uint32 weight_kg;
        uint price;
        uint unique_id;
    }


    uint public constant life_of_a_product = 10 days; // for semplicity I define that all products last 10 days
    uint public constant modulus = 10**15; // for pseudo-random number generator

    mapping(uint => Product_M) public mapping_m;
    /* since a product can be bought by more distributors or retailer we cannot use the same previous type of 
    storage, so we have several alternatives, and I choose this one: (where string is the name of the firm)*/
    mapping(uint => mapping(string => Product_D)) public mapping_d;
    mapping(uint => mapping(string => Product_R)) public mapping_r;

    // I create an event for each possible status;
    event _Manufactured(uint indexed unique_id, address owner);
    event _Sold_to_Distributor(uint indexed unique_id, address indexed from, address indexed to);
    event _Available_to_Distributor(uint indexed unique_id, address indexed owner);
    event _Sold_to_Retailer(uint indexed unique_id, address indexed from, address indexed to);
    event _Exhibited(uint indexed unique_id, address indexed owner);
    event _Sold_to_Consumer(uint indexed unique_id, address indexed from, address indexed to);

    /* the unique identifier of a product will be a random number 
    generated by keccak256 that takes two variables...for simplicity
    we consider just the last 15 digits of this number.*/
    function pseudorandom_number_generator(string memory firm_name) private view returns(uint){
        uint unique_id = uint(keccak256(abi.encodePacked(block.timestamp, firm_name)));
        unique_id = unique_id % modulus;
        return unique_id;
    }

    // function that 'creates' the product
    function createProduct(uint32 _weight, uint _price, string memory _product_name) public onlyFarmer {
        // push in array
        string memory _name_f = name_f[msg.sender]; // for simplicity define a variable
        uint _unique_id = pseudorandom_number_generator(_name_f);
        mapping_m[_unique_id] = Product_M(msg.sender,_name_f,seat_f[_name_f],_product_name,uint32(block.timestamp),
                                                    uint32(block.timestamp+life_of_a_product),_weight, _price,
                                                                                                _unique_id);                                                                                     
        emit _Manufactured(_unique_id, msg.sender);
    }

    // function that allow distributor to purchase the product
    function buy_D_product(uint32 _weight, uint _unique_id, uint price_tobe_paid) external // we give price_tobe_paid from frontend, it's not safe compute a proportion in solidity
    onlyDistributor manufactured_exists(_unique_id) payable {
        require(_weight != 0, "Wrong weight parameter");
        Product_M storage my_product1 = mapping_m[_unique_id];
        address farmer_tobe_paid = my_product1.farm_address;
        // in case desired weight is more than what i have
        //(,_weight) = maximum(my_product1.weight_kg,_weight);
        // compute the price for that weight
        //uint proportion = (my_product1.weight_kg * (100*100)) / my_product1.price; //multiply twice by 100 so I avoid division by zero error
        //uint price_tobe_paid = ((100*100) * _weight) / proportion;
        require(msg.value >= price_tobe_paid, "need more cash");
        // refund the surplus paid
        if (msg.value > price_tobe_paid){
            payable(msg.sender).transfer(msg.value - price_tobe_paid);
        }
        // transfer money to farmer
        payable(farmer_tobe_paid).transfer(price_tobe_paid);
        // add it to mapping distributor archive this unique id
        string memory name_distributor = name_d[msg.sender];
        mapping_d[_unique_id][name_distributor] = Product_D(msg.sender, name_distributor, my_product1.product_name, 
                                                            _unique_id, 0, _weight,my_product1.production_date, my_product1.expiration_date);
        /* if weight of this manufactured product becomes 0, delete this mapping from 'manufacturer mapping',
        in this way the product is no longer available */
        my_product1.weight_kg = my_product1.weight_kg - _weight;
        my_product1.price = my_product1.price - price_tobe_paid;
        if (my_product1.weight_kg == 0){
            delete mapping_m[_unique_id];
        }

        emit _Sold_to_Distributor(_unique_id, farmer_tobe_paid, msg.sender);
    }
    

    // function that specify the product's availability for the distributor and specify the price for distributor
    function available_d(uint _unique_id, uint _new_price)
    external onlyDistributor {
        require(_new_price != 0, "Wrong price parameter");
        string memory _name_distributor = name_d[msg.sender];
        Product_D storage my_product = mapping_d[_unique_id][_name_distributor];
        require(my_product.distr_address == msg.sender, "It's not your product");
        my_product.price = _new_price;
        emit _Available_to_Distributor(_unique_id, msg.sender);
    }

    // function that allow Retailer to purchase the product
    function buy_R_product(uint32 _weight, uint _unique_id, uint price_tobe_paid, string memory _name_distributor) 
    external onlyRetailer distributor_exists(_unique_id, _name_distributor) 
    check_availability(_unique_id, _name_distributor) payable {
        require(_weight != 0 , "Wrong weight parameter");
        Product_D storage my_product3 = mapping_d[_unique_id][_name_distributor];
        address distributor_tobe_paid = my_product3.distr_address;
        require(msg.value >= price_tobe_paid, "need more cash");
        // refund the surplus paid
        if (msg.value > price_tobe_paid){
            payable(msg.sender).transfer(msg.value - price_tobe_paid);
        }
        // transfer money to distributor
        payable(distributor_tobe_paid).transfer(price_tobe_paid);
        // add it to mapping retailer archive this unique id
        string memory _name_retailer = name_r[msg.sender];
        mapping_r[_unique_id][_name_retailer] = Product_R(msg.sender, _name_retailer,seat_r[_name_retailer],my_product3.product_name,
                                                                        my_product3.production_date, my_product3.expiration_date,_weight,0, _unique_id
                                                                        );
        /* if weight of this product becomes 0, delete this mapping from 'distributor mapping',
        in this way the product is no longer available */
        my_product3.weight_kg = my_product3.weight_kg - _weight;
        my_product3.price = my_product3.price - price_tobe_paid;
        if (my_product3.weight_kg == 0){
            delete mapping_d[_unique_id][_name_distributor];
        }

        emit _Sold_to_Retailer(_unique_id, distributor_tobe_paid, msg.sender);
    }
       

    // function that specify ==> the products is in exposition, available to be bought by consumer
    function is_ready(uint _unique_id, uint _new_price) external onlyRetailer{
        require(_new_price != 0, "Wrong price parameter");
        string memory _name_retailer = name_r[msg.sender];
        Product_R storage my_product = mapping_r[_unique_id][_name_retailer];
        require(my_product.ret_address == msg.sender, "It's not your product");
        my_product.price = _new_price;
        emit _Exhibited(_unique_id, msg.sender);
    }

    // final supply chain function that allow consumer to purchase a product
    function final_buy(uint32 _weight, uint _unique_id, uint price_tobe_paid, string memory _name_retailer) external 
    onlyConsumer retailer_exists(_unique_id, _name_retailer) spoiled(_unique_id)
    check_exhibition(_unique_id, _name_retailer) payable{
        Product_R storage my_product3 = mapping_r[_unique_id][_name_retailer];
        address retailer_tobe_paid = my_product3.ret_address;
        require(msg.value >= price_tobe_paid, "need more cash");
        // refund the surplus paid
        if (msg.value > price_tobe_paid){
            payable(msg.sender).transfer(msg.value - price_tobe_paid);
        }
        // transfer money to retailer
        payable(retailer_tobe_paid).transfer(price_tobe_paid);
        /* if weight of this product becomes 0, delete this mapping from 'retailer mapping',
        in this way the product is no longer available */
        my_product3.weight_kg = my_product3.weight_kg - _weight;
        my_product3.price = my_product3.price - price_tobe_paid;
        if (my_product3.weight_kg == 0){
            delete mapping_r[_unique_id][_name_retailer];
        }

        emit _Sold_to_Consumer(_unique_id, retailer_tobe_paid, msg.sender);
    }
    

    /* now define three modifiers where I wanna catch errors: mapping key doesn t exists.
    We know that the entire mapping storage space is initialized with 0, so: */

    modifier manufactured_exists(uint _unique_id){
        require(mapping_m[_unique_id].weight_kg>0, "You cant buy a product that's not manufactured");
        _;
    }

    modifier distributor_exists(uint _unique_id, string memory _name_distributor){

        require(mapping_d[_unique_id][_name_distributor].weight_kg>0, "This distributor doesn t have this product");
        _;
    }
    
    modifier retailer_exists(uint _unique_id, string memory _name_retailer){
        require(mapping_r[_unique_id][_name_retailer].weight_kg>0, "This retailer doesn t have this product");
        _;
    }

    /* We define two modifiers, the first one allow to check if a product is availble in order to be bought by retailer, 
    the other one allow to check if a product is exhibited in order to be bought by consumer */

    modifier check_availability(uint _unique_id, string memory _name_distributor){
        require(mapping_d[_unique_id][_name_distributor].price>0, "This distributor'product is not yet available");
        _;
    }

    modifier check_exhibition(uint _unique_id, string memory _name_retailer){
        require(mapping_r[_unique_id][_name_retailer].price>0, "This retailer'product is not yet exhibited");
        _;
    }

    // now define a modifier that checks if the product is spoiled
    modifier spoiled(uint _unique_id) {
        require(mapping_m[_unique_id].expiration_date > block.timestamp, 'This product is spoiled');
        _;
    }


    // define a function that allow the Owner to destruct the contract
    function destruct() public onlyOwner {
        selfdestruct(payable(msg.sender));
    }

}
